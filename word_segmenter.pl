#!/usr/bin/perl -sw
#
### word_segmenter.pl
# segments Japanese input. 
# To avoid superfluous or wrong tokenization by the external segmenter (mainly on Latin substrings or punctuation) this script introduces placeholders during segmentation. These placeholders are restored to the proper text after segmentation.
#
# ©2011–2012 Autodesk Development Sàrl
# Created by François Masselot
#
# Latest change 13.02.2012 by Ventsislav Zhechev
# v2.0.1
# ⇒ Fixed a bug where the segmenter tool file handles were not autoflushed and could cause a stall in data processing.
#
# Changed 07.02.2012 by Ventsislav Zhechev
# v2.0
# ⇒ Now sending lists of arguments to open2() to avoid involving the shell.
#
# Changed 18.09.2011 by Ventsislav Zhechev
# ⇒ Updated for use with KyTea v0.3+
#
# Changed on 30.04.2011 by Ventsislav Zhechev
# ⇒ Added \p{Script:Han} for more complete coverage of Japanese
#
# Changed on 01.04.2011 by Ventsislav Zhechev
# ⇒ Switched from \x to \p character descriptors in the regex to improve readability
#
# Changed on 18.02.2011 by Ventsislav Zhechev
# ⇒ The paths to the segmenter executable and model can now be passed as a command-line argument. Use the -seg_path and -model arguments.
#
# Changed on 17.02.2011 by Ventsislav Zhechev
# ⇒ We should require the arguments to the script to be passed via explicit switches. At least on MacOSX there seems to be a mix-up in the handling of Unicode input if the input file name is passed as a plain string on the command line.
#		The -segmenter= argument should be used to select the desired program (mecab or kytea).
#		The -input= argument should be used to specify the input file; In order to read input from STDIN, this switch should be simply omitted.
#
# Changed on 16.02.2011 by Ventsislav Zhechev
# ⇒ A major rewrite to eliminate the use of files on disk and run the external segmenter via a bi-directional pipe. Reworked the placeholder handling, adding a failsafe mechanism in case the currently selected placeholder is present in the raw input. Made sure that the script can be used in a pipe.
#
##################################################

use strict;
use utf8;

use IO::Handle;

# Turn autoflush on
$| = 1;


# Import the variables generated by the command-line switches
our ($segmenter, $input, $seg_path, $model);

die "Unavailable segmenter selected: $segmenter (should be mecab or kytea)\n" unless ($segmenter eq "mecab" || $segmenter eq "kytea");

use IPC::Open2;

binmode STDIN,':encoding(utf-8)';
binmode STDOUT,':encoding(utf-8)';
binmode STDERR,':encoding(utf-8)';

# list of possible placeholders
my @PH = ("", "⌘", "☺", "☹", "∅", "⇅", "⌥", "⊬", "⊭", "⊨");

# Make sure we only output status messages on STDERR if we are run in an interactive environment
my $tty = -t STDIN;


if ($seg_path) {
	$seg_path .= "/" if ($seg_path =~ m![^/]$!);
} else {
	$seg_path = "";
}
print STDERR "Using segmenter “${seg_path}$segmenter”\n" if ($tty && $seg_path);
$model ||= "";
$model = ['-d', "$model"] if ($segmenter eq "mecab" && $model);
$model = ['-model', "$model"] if ($segmenter eq "kytea" && $model);
print STDERR "Using model “@$model”\n" if ($tty && $model);

# Run the external segmenter through a two-way pipe
print STDERR "Starting segmenter…" if $tty;
my ($SEG_IN, $SEG_OUT);
my $seg_pid = $segmenter eq "mecab" ?
							open2($SEG_OUT, $SEG_IN, "${seg_path}mecab", '-O', 'wakati', @$model) :
							open2($SEG_OUT, $SEG_IN, "${seg_path}kytea", '-notags', '-out', 'part', '-nobound', '', '-hasbound', ' ', @$model)
or die "Could not start segmenter “$segmenter”!\n";
print STDERR "done\n" if $tty;

# Make sure these handles are also autoflushed and with the correct encoding
binmode $SEG_IN,':encoding(utf-8)';
$SEG_IN->autoflush(1);
binmode $SEG_OUT,':encoding(utf-8)';
$SEG_OUT->autoflush(1);

local $SIG{PIPE} = sub { die "Segmenter pipe seems to be broken. Aborting…\n" };


# Redirect STDIN if we are reading from a file
if ($input) {
	close STDIN;
	open (STDIN, "<:encoding(utf-8)", $input)
	or die "Cannot open: $input";
}

while (<>){
	# Shortcut for empty input
	unless ($_) {
		print;
		next;
	}
	chomp;
	# We need two copies of the input line: one working copy that will be modified and one master copy from which we will restore the non-japanese text
	my $orig_line = my $line = $_;

	# Select a placeholder character that does not exist in the current input
	my $ph = 0; ++$ph while (/$PH[$ph]/ && $ph < $#PH);

	# progress dots based on input filehandle line numbers
	if ($tty && $. % 10000 eq 0) {print STDERR ".";}

	# substitute placeholders for all substrings consisting of only non-japanese characters
	$line =~ s/(?:[^\p{Script:Hiragana}\p{Script:Katakana}\p{Script:Han}]| )+/ $PH[$ph] /g;
	$line =~ s/^ +| +$//g;
	
	# Run the input through the segmenter
	print $SEG_IN "$line\n";
	my $new_line = <$SEG_OUT>;
	chomp $new_line;
	$new_line =~ s/ +/ /g;
	$new_line =~ s/^ +| +$//g;
	
	# Generate the result string by concatenating the segmented foreign segments with the strings corresponding to the placeholders
	my $result = my $part = "";
#	print STDERR "O:“$orig_line”\tN:“$new_line”\n";
	while ($orig_line || $new_line) {
		if ($new_line && (($part) = $new_line =~ /^([\p{Script:Hiragana}\p{Script:Katakana}\p{Script:Han} ]+)/)) {
			$orig_line =~ s/^[\p{Script:Hiragana}\p{Script:Katakana}\p{Script:Han}]+//;			
			$new_line =~ s/^[\p{Script:Hiragana}\p{Script:Katakana}\p{Script:Han} ]+//;
#			print STDERR "O:“$orig_line”\tN:“$new_line”\n";
		} else {
			($part) = $orig_line =~ /^((?:[^\p{Script:Hiragana}\p{Script:Katakana}\p{Script:Han}]| )+)/;
			$orig_line =~ s/^(?:[^\p{Script:Hiragana}\p{Script:Katakana}\p{Script:Han}]| )+//;
			$new_line =~ s/^$PH[$ph] ?//g;
#			print STDERR "O:“$orig_line”\tN:“$new_line”\n";
		}
		$result .= "$part ";
#		print STDERR "\tP:“$part”\tR:“$result”\n";
	}
	$result =~ s/ +/ /g;
	$result =~ s/ $//;
	
	print "$result\n";
}


close $SEG_IN;
close $SEG_OUT;
waitpid($seg_pid, 0);

close STDIN if $input;

1;